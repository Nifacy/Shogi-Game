# Микросервисы

Разбив задачу на части, мы можем выделить следующие функциональные блоки:
* Аккаунты
* Авторизация
* Комнаты
* Игровые сессии
* Приватные комнаты
* Автопоиск

Каждому функциональному блоку будет соответствовать отдельный микросервис. Для
компоновки всей системы микросервисов в одно целое будет реализован API Gateway,
который также является и входной точкой для клиента.

Одни из свойств микросервисов - ограниченный контекст и автономность. Поэтому,
при построении архитектуры мы придерживались идеи сведения к минимуму общения
между микросервисами, так как в противном случае бизнес логика одного сервиса
будет зависеть от бизнес логики другого, что делает его не автономным. Например,
если сервис сессий будет связан с аккаунтами, то запустить его отдельно без
соответствующего микросервиса уже невозможно.

Однако, ограничение полностью достичь не удастся, так как бизнес логика некоторых
микросервисов тесно связана с логикой других (например, сервис приватных комнат,
очевидно, будет связан с сервисом обычных комнат).

Также, при определении способа общения микросервисов мы остановились на применении
RPC, так как все взаимодействие с сервисами в основном попадает под шаблон
`Requiest / Reply`.

## Сервис игровых сессий

<img width="348" alt="image" src="https://user-images.githubusercontent.com/95340036/212655835-24e5fe66-fa48-4c8f-9852-8097a84c9062.png">

Ответственность сервера заключается в:
* Создание игровых сессий
* Завершение игровых сессий
* Обработка входных команд от пользователей
* Уведомление пользователей об изменении игрового состояния

Так как мы придерживались идеи автономности микросервисов, то сервис сессий
не связан с системой аккаунтов, что сильно повлияло на внешний интерфейс
взаимодействия с микросервисом.

Для создания игровой сессии достаточно вызвать соответствующий метод. Так как сервис
не связан с системой аккаунтов и будет использоваться лишь внутри системы (пользователь
напрямую не общается с микросервисомами кроме API Gateway), то из информации достаточно
указать имена игроков, чтобы можно было узнать, от лица какого игрока нужно обработать
входную команду. При этом, при создании сессии игра считывается уже начавшейся.

Как уже было сказано в описании задачи, завершение процесса инкапсулировано. То есть,
никакого определенного метода для закрытия сессии не существует. Достаточно лишь
закрыть соединение.

При создании соединения между микросервисом и клиентской частью системы необходимо сначала
отправить имя игрока, от лица которого будут в дальнейшем приходить все команды. Таким
способом мы можем установить соответствие `Соединение -> Имя`, чтобы в дальнейшем понимать,
кто отключился или кому отправлять сообщение.

## Комнаты

<img width="314" alt="image" src="https://user-images.githubusercontent.com/95340036/212656316-869e97ac-5b39-4fd0-8db2-3e74b30bc29e.png">

Сервис приватных комнат ответственен за создание приватных комнат, подключение к ним и закрытие
приватной комнаты. При этом, при заполнении приватной комнаты создается игровая сессия, что
обуслвавливает зависимость данного микросервиса от микросервиса игровых сессий.

Уведомление подключенных игроков о том, что комната была заполнена происходит через exchange
под названием `private_room.events` (подробности о реализации событий смотрите в разделе
[AMQP События](#Cобытия-через-AMQP))

## Поиск игроков

<img width="333" alt="image" src="https://user-images.githubusercontent.com/95340036/212658232-f78ab555-7f2e-4ec9-9b43-f03ebbd84abb.png">

Сервис поиска игроков по необходимым параметрам ответственен за реализацию следующего функционала:
* Запустить поиск соперника для пользователя
* Приостановить поиск для пользователя

Если соперник был успешно найден, то уведомление происходит через exchange под названием `searcher_service.events`.

Для хранения запросов пользователей рационально было выбрать сервер баз данных на подобии Redis,
однако текущая разработка использует сырую реализацию на основе обычных словарей Python.

## Авторизация

<img width="495" alt="image" src="https://user-images.githubusercontent.com/95340036/212657629-670d7083-9281-430e-8169-4b5163450ece.png">

Ответственен за регистрацию / авторизацию / аутентификацию пользователей. Используется стандарт `JWT` для
генерации токенов доступа. Все пароли должны находиться в базе данных в зашифрованном виде.

Так как микросервисы должны быть автономны, то мы в базе данных храним исключительно данные для входа пользователей:
* Логин пользователя
* Зашифрованный пароль

## Сервис аккаунтов

<img width="362" alt="image" src="https://user-images.githubusercontent.com/95340036/212657101-40531e82-76aa-4a4c-ae25-59b5c0194cea.png">

Ответственен за реализацию CRUD операций над аккаунтами пользователей.

# Cобытия через AMQP

<img width="575" alt="image" src="https://user-images.githubusercontent.com/95340036/212654017-fb03c51e-8098-4b82-83f1-fba2553b0b6c.png">

При разработке системы возникла необходимость в реализации механизма асинхронной
отправки результатов со стороны сервиса. Решением этой проблемы стало использования
шаблона обмена сообщениями `Publish / Subscribe` из RabbitMQ.

При таком подходе мы создаем специальный exchange типа FANOUT. Exchange такого типа
теперь отправляет сообщениям всем очередям, привязанным к нему по соответствующему `route_key`.

Однако, у такого типа exchange есть особенность, которую мы использовали. Если ничего
не указывать в поле `route_key` при привязке очереди к exchange или отправке сообщений по нему,
то сообщение будет отправляться абсолютно всем привязанным очередям.

Таким образом мы можем организовать подписку на получение уведомлений со стороны клиента путем
создания временной анонимной очереди и привязке ее к exchange, используя который сервис отправляет
сообщения.

# Ссылки

* [Диаграмма архитектуры](https://drive.google.com/file/d/1qgUQQ9BpgZGs5R3lNjquvmeF08rFt42I/view?usp=sharing)
